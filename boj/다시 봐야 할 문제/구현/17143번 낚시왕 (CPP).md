# [BOJ] 17143번 낚시왕 (CPP)

백준온라인저지(BOJ) https://www.acmicpc.net/problem/17143

아이디: song98987


## 1. 문제 설명

#### 문제
낚시왕이 상어 낚시를 하는 곳은 크기가 R×C인 격자판으로 나타낼 수 있다. 격자판의 각 칸은 (r, c)로 나타낼 수 있다. r은 행, c는 열이고, (R, C)는 아래 그림에서 가장 오른쪽 아래에 있는 칸이다. 칸에는 상어가 최대 한 마리 들어있을 수 있다. 상어는 크기와 속도를 가지고 있다.

낚시왕은 처음에 1번 열의 한 칸 왼쪽에 있다. 다음은 1초 동안 일어나는 일이며, 아래 적힌 순서대로 일어난다. 낚시왕은 가장 오른쪽 열의 오른쪽 칸에 이동하면 이동을 멈춘다.

1. 낚시왕이 오른쪽으로 한 칸 이동한다.
2. 낚시왕이 있는 열에 있는 상어 중에서 땅과 제일 가까운 상어를 잡는다. 상어를 잡으면 격자판에서 잡은 상어가 사라진다.
3. 상어가 이동한다.

상어는 입력으로 주어진 속도로 이동하고, 속도의 단위는 칸/초이다. 상어가 이동하려고 하는 칸이 격자판의 경계를 넘는 경우에는 방향을 반대로 바꿔서 속력을 유지한채로 이동한다.

상어가 이동을 마친 후에 한 칸에 상어가 두 마리 이상 있을 수 있다. 이때는 크기가 가장 큰 상어가 나머지 상어를 모두 잡아먹는다.

낚시왕이 상어 낚시를 하는 격자판의 상태가 주어졌을 때, 낚시왕이 잡은 상어 크기의 합을 구해보자.

#### 입력
첫째 줄에 격자판의 크기 R, C와 상어의 수 M이 주어진다. (2 ≤ R, C ≤ 100, 0 ≤ M ≤ R×C)

둘째 줄부터 M개의 줄에 상어의 정보가 주어진다. 상어의 정보는 다섯 정수 r, c, s, d, z (1 ≤ r ≤ R, 1 ≤ c ≤ C, 0 ≤ s ≤ 1000, 1 ≤ d ≤ 4, 1 ≤ z ≤ 10000) 로 이루어져 있다. (r, c)는 상어의 위치, s는 속력, d는 이동 방향, z는 크기이다. d가 1인 경우는 위, 2인 경우는 아래, 3인 경우는 오른쪽, 4인 경우는 왼쪽을 의미한다.

두 상어가 같은 크기를 갖는 경우는 없고, 하나의 칸에 둘 이상의 상어가 있는 경우는 없다.

#### 출력
낚시왕이 잡은 상어 크기의 합을 출력한다.

## 2. 내 소스 코드

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int r, c, m, ans=0, nr, nc;
    tuple<int,int,int> b[101][101]; // 초기화 방법 익히기
    int dx[4] = {0,0,1,-1}; // 상하우좌로 변경
    int dy[4] = {-1,1,0,0};
    
    cin >> r >> c >> m;
    int x, y, s, d, z;

    for (int i=0; i<m; i++) {
        cin >> y >> x >> s >> d >> z;

        if (d<=2) {
            s %= (2*r-2);
        } else {
            s %= (2*c-2);
        }

        b[y-1][x-1] = {s,d-1,z};
    }

    // 낚시왕 이동
    for (int pos=0; pos<c; pos++) {        
        // 땅과 가장 가까운 상어 잡음
        for (int i=0; i<r; i++) {
            if (get<2>(b[i][pos]) != 0) {
                ans += get<2>(b[i][pos]);
                b[i][pos] = {0,0,0};
                break;
            }
        }

        // 상어 이동
        tuple<int, int, int> bt[101][101];
        for (int i=0; i<r; i++) {
            for (int j=0; j<c; j++) {
                if (get<2>(b[i][j]) != 0) {
                    tie(s,d,z) = b[i][j];

                    nr = i; nc = j;
                    for (int k=0; k<s; k++) {
                        switch (d) {
                        case 0: // 상
                            nr = nr + dy[d];
                            if (!(0<=nr&&nr<r)) {
                                d = 1;
                                nr = 1;
                            }
                            break;
                        case 1: // 하
                            nr = nr + dy[d];
                            if (!(0<=nr&&nr<r)) {
                                d = 0;
                                nr = r-2;
                            }
                            break;
                        case 2: // 우
                            nc = nc + dx[d];
                            if (!(0<=nc&&nc<c)) {
                                d = 3;
                                nc = c-2;
                            }
                            break;
                        case 3: // 좌
                            nc = nc + dx[d];
                            if (!(0<=nc&&nc<c)) {
                                d = 2;
                                nc = 1;
                            }
                            break;
                        }
                    }
                    
                    if (get<2>(bt[nr][nc]) == 0 || get<2>(bt[nr][nc]) < z) {
                        bt[nr][nc] = {s,d,z};
                    }
                }
            }
        }

        // 더 쉽게 copy 할 수 있는 방법 있는지 찾기
        for (int i=0; i<r; i++) {
            for (int j=0; j<c; j++) {
                b[i][j] = bt[i][j];
            }
        }
    }

    cout << ans;
}
```

## 3. 개선점

결국 답지를 봤던 문제

57~61 줄이 포인트이다.

상어의 이동에 더 수학적으로 접근할 수도 있다.

참고 코드: https://www.acmicpc.net/source/33111472